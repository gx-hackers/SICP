# そういえば実は前回やってなかった
## Clojure
user=> (print "HelloWorld!")  
HelloWorld!nil  

user=> (println "Hello World")  
Hello World  
nil  
## Gauche
gosh> (print "HelloWorld!")  
HelloWorld!  

# 前回の復習から基本
* 最小単位はアトム  
123 => 123  
* Lispでは演算子が最初に来る（前置記法）そしてこれはS式という  
(+ 1 2) => 3  
* ネストの深さは無限（処理系の実装依存？）  
(+ (+ 1 2) (* 2 3)) => 9  
* 変数の束縛  
gosh> (define a 1)  
a  
gosh> a  
1  
gosh> (define b 2)  
b  
gosh> (+ a b)  
3  
* 再帰がややこしくなったら'木構造のため込み'(図1.1)  
gosh> (* (* 2 3) (* 4 5))  
120  
* 数字列は数として、
 * 123(いち・に・さん)を評価すると123(ひゃくにじゅうさん)
* 基本演算子は対応する演算の機械命令として、
 * +や*は大域環境に含まれている
 * 演算子+が加算命令に意味づけているのが大域環境
* それ以外はその環境で対応付けられたオブジェクト(?)として評価

## 特殊形式: 一般評価規則の例外
* すべての引数を必ず評価するわけではない関数(のようなもの)
* (define a 1)を評価した場合
 * 定義(defineがaと1に作用している)しているのではない
 * aに値を結びつけるだけ
* つまり'基本式'の'組み合わせ'ではない
* (exit)は引数を取らない関数＝通常の手続き

# 1.1.4 合成手続き
gosh> (define (square x) (* x x))
square  
gosh> (square 3)  
9  
gosh> (square (square 3))  
81  

* こういうのを組み合わせて様々な処理を作っていく  
* 名前空間が無いので、組み込み関数をユーザ定義関数で上書きできてしまうので注意  

# 1.1.5 手続き作用の置き換えモデル
* 正規順序
 * 「完全に展開し、簡約する」
 * defineを辿っていって、基本演算子だけが残ったら評価
* 作用的順序
 * 「引数を評価し、作用させる」
 * defineした手続きを直接適用
* 正規順序と作用的順序の評価が一致しない「不当な値」もある(問題1.5)
* 多重評価による効率低下の防止を目的に、Lispは作用的順序を処理系で採用

# 1.1.6 条件式と述語
## 絶対値を返したい
### ifを使う方法(特殊形式)
```Scheme
(define (abs x)  
  (if (< x 0)  
    (- x)  ; -演算子は引数が1つの時に正負を反転する特殊な挙動
    x))  
```
### condを使う方法(特殊形式)  
```Scheme
(define (abs x)  
  (cond ((< x 0)  
    (- x))  
    (else x)))  
```

* 和氣さんの解説!  
condは、  
```Scheme
(cond ((条件) (フォーム))  
      ((条件) (フォーム))  
      …  
      (else フォーム))  
```
となって、括弧が2重になります。  
ちなみにClojureだとこれが簡略化されて  
```Clojure
(cond (条件) (フォーム)  
      (条件) (フォーム)  
      …  
      :else (フォーム))  
```
って直感的で書きやすくなってます！

### CommonLispでは、ifを複数置きたいときprognも使える  
```CommonLisp
(if 条件式  
  (progn  
    真フォーム１  
    真フォーム２  
    …  
  偽フォーム１  
  偽フォーム２  
  … ))  
```
ただこれだと新フォームと偽フォームでインデントがずれて見栄えも悪いので、condを使いましょうって話です。  
by 和氣さん  

### 論理合成演算子も色々ある
* 基本的述語
 * <
 * \>
 * =
* 論理合成演算子
 * and
 * or
 * not
* and, orは全ての引数を評価するとは限らないので特殊形式
* notは通常の手続き

# 問題コーナー
## 問題1.4
* (- 1)で正の数1に演算子-を適用して負数を表している
* 条件分岐で演算子を分ける、前置記法独自の書き方  
gosh> (define (a-plus-abs-b a b)  
( (if (> b 0)  
\+  
-)  
a b))  

gosh> (a-plus-abs-b 1 2)  
3  
gosh> (a-plus-abs-b 1 -2)  
3  

## 問題1.5
みんなでかんがえよう  
